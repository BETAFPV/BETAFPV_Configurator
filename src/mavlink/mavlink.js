/*
MAVLink protocol implementation for node.js (auto-generated by mavgen_javascript.py)

Generated from: message_definitions.xml

Note: this file has been auto-generated. DO NOT EDIT
*/

jspack = require("jspack").jspack,
    _ = require("underscore"),
    events = require("events"),
    util = require("util");

// Add a convenience method to Buffer
Buffer.prototype.toByteArray = function () {
  return Array.prototype.slice.call(this, 0)
}

mavlink10 = function(){};

// Implement the CRC-16/MCRF4XX function (present in the Python version through the mavutil.py package)
mavlink10.x25Crc = function(buffer, crcIN) {

    var bytes = buffer;
    var crcOUT = crcIN || 0xffff;
    _.each(bytes, function(e) {
        var tmp = e ^ (crcOUT & 0xff);
        tmp = (tmp ^ (tmp << 4)) & 0xff;
        crcOUT = (crcOUT >> 8) ^ (tmp << 8) ^ (tmp << 3) ^ (tmp >> 4);
        crcOUT = crcOUT & 0xffff;
    });
    return crcOUT;

}

mavlink10.WIRE_PROTOCOL_VERSION = "1.0";
mavlink10.HEADER_LEN = 6;

mavlink10.MAVLINK_TYPE_CHAR     = 0
mavlink10.MAVLINK_TYPE_UINT8_T  = 1
mavlink10.MAVLINK_TYPE_INT8_T   = 2
mavlink10.MAVLINK_TYPE_UINT16_T = 3
mavlink10.MAVLINK_TYPE_INT16_T  = 4
mavlink10.MAVLINK_TYPE_UINT32_T = 5
mavlink10.MAVLINK_TYPE_INT32_T  = 6
mavlink10.MAVLINK_TYPE_UINT64_T = 7
mavlink10.MAVLINK_TYPE_INT64_T  = 8
mavlink10.MAVLINK_TYPE_FLOAT    = 9
mavlink10.MAVLINK_TYPE_DOUBLE   = 10

mavlink10.MAVLINK_IFLAG_SIGNED = 0x01

// Mavlink headers incorporate sequence, source system (platform) and source component. 
mavlink10.header = function(msgId, mlen, seq, srcSystem, srcComponent, incompat_flags=0, compat_flags=0,) {

    this.mlen = ( typeof mlen === 'undefined' ) ? 0 : mlen;
    this.seq = ( typeof seq === 'undefined' ) ? 0 : seq;
    this.srcSystem = ( typeof srcSystem === 'undefined' ) ? 0 : srcSystem;
    this.srcComponent = ( typeof srcComponent === 'undefined' ) ? 0 : srcComponent;
    this.msgId = msgId
    this.incompat_flags = incompat_flags
    this.compat_flags = compat_flags

}

mavlink10.header.prototype.pack = function() {
    return jspack.Pack('BBBBBB', [254, this.mlen, this.seq, this.srcSystem, this.srcComponent, this.msgId]);
}
        
// Base class declaration: mavlink.message will be the parent class for each
// concrete implementation in mavlink.messages.
mavlink10.message = function() {};

// Convenience setter to facilitate turning the unpacked array of data into member properties
mavlink10.message.prototype.set = function(args) {
    _.each(this.fieldnames, function(e, i) {
        this[e] = args[i];
    }, this);
};

// This pack function builds the header and produces a complete MAVLink message,
// including header and message CRC.
mavlink10.message.prototype.pack = function(mav, crc_extra, payload) {

    this.payload = payload;
    var plen = this.payload.length;
    var incompat_flags = 0;
    this.header = new mavlink10.header(this.id, this.payload.length, mav.seq, mav.srcSystem, mav.srcComponent, incompat_flags, 0,);    
    this.msgbuf = this.header.pack().concat(this.payload);
    var crc = mavlink10.x25Crc(this.msgbuf.slice(1));

    // For now, assume always using crc_extra = True.  TODO: check/fix this.
    crc = mavlink10.x25Crc([crc_extra], crc);
    this.msgbuf = this.msgbuf.concat(jspack.Pack('<H', [crc] ) );
    return this.msgbuf;

}


// enums

// message IDs
mavlink10.MAVLINK_MSG_ID_BAD_DATA = -1
mavlink10.MAVLINK_MSG_ID_HEARTBEAT = 1
mavlink10.MAVLINK_MSG_ID_FIRMWARE_INFO = 2
mavlink10.MAVLINK_MSG_ID_SYS_STATUS = 3
mavlink10.MAVLINK_MSG_ID_IMU = 4
mavlink10.MAVLINK_MSG_ID_ATTITUDE = 5
mavlink10.MAVLINK_MSG_ID_LOCAL_POSITION = 6
mavlink10.MAVLINK_MSG_ID_RC_CHANNELS = 7
mavlink10.MAVLINK_MSG_ID_COMMAND = 8
mavlink10.MAVLINK_MSG_ID_COMMAND_ACK = 9
mavlink10.MAVLINK_MSG_ID_STATUS_TEXT = 10
mavlink10.MAVLINK_MSG_ID_MOTORS_TEST = 11
mavlink10.MAVLINK_MSG_ID_ALTITUDE = 12
mavlink10.MAVLINK_MSG_ID_RATE = 13
mavlink10.MAVLINK_MSG_ID_PID = 14
mavlink10.messages = {};

/* 
heartbeat message (1HZ)

                flightMode                : Flight mode. (uint8_t)
                armedStatus               : armed status. (uint8_t)

*/
mavlink10.messages.heartbeat = function(flightMode, armedStatus) {

    this.format = '<BB';
    this.id = mavlink10.MAVLINK_MSG_ID_HEARTBEAT;
    this.order_map = [0, 1];
    this.crc_extra = 196;
    this.name = 'HEARTBEAT';

    this.fieldnames = ['flightMode', 'armedStatus'];


    this.set(arguments);

}
        mavlink10.messages.heartbeat.prototype = new mavlink10.message;
mavlink10.messages.heartbeat.prototype.pack = function(mav) {
    return mavlink10.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.flightMode, this.armedStatus]));
}

/* 
versions of flight control

                targetId                  : Type of the FC:[0 for unknow] [1 for Cetus] [2 for Cetus pro]. (uint8_t)
                majorVersion              : The majorVersion of FC. (uint8_t)
                minorVersion              : The minorVersion of FC. (uint8_t)
                patchVersion              : The patchVersion if FC. (uint8_t)
                year                      : The year of firmware build. (uint16_t)
                month                     : The month of firmware build. (uint8_t)
                day                       : The day of firmware build. (uint8_t)

*/
mavlink10.messages.firmware_info = function(targetId, majorVersion, minorVersion, patchVersion, year, month, day) {

    this.format = '<HBBBBBB';
    this.id = mavlink10.MAVLINK_MSG_ID_FIRMWARE_INFO;
    this.order_map = [1, 2, 3, 4, 0, 5, 6];
    this.crc_extra = 170;
    this.name = 'FIRMWARE_INFO';

    this.fieldnames = ['targetId', 'majorVersion', 'minorVersion', 'patchVersion', 'year', 'month', 'day'];


    this.set(arguments);

}
        mavlink10.messages.firmware_info.prototype = new mavlink10.message;
mavlink10.messages.firmware_info.prototype.pack = function(mav) {
    return mavlink10.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.year, this.targetId, this.majorVersion, this.minorVersion, this.patchVersion, this.month, this.day]));
}

/* 
system status

                sensorsPresent            : showing which sensors are present. (uint8_t)
                sensorsEnabled            : showing which sensors are enabled. (uint8_t)
                sensorsHealth             : showing which sensors are are operational or have an error. (uint8_t)
                voltageBattery            : Battery voltage. (float)
                currentBattery            : Battery current, -1: does not measure the current. (float)

*/
mavlink10.messages.sys_status = function(sensorsPresent, sensorsEnabled, sensorsHealth, voltageBattery, currentBattery) {

    this.format = '<ffBBB';
    this.id = mavlink10.MAVLINK_MSG_ID_SYS_STATUS;
    this.order_map = [2, 3, 4, 0, 1];
    this.crc_extra = 83;
    this.name = 'SYS_STATUS';

    this.fieldnames = ['sensorsPresent', 'sensorsEnabled', 'sensorsHealth', 'voltageBattery', 'currentBattery'];


    this.set(arguments);

}
        mavlink10.messages.sys_status.prototype = new mavlink10.message;
mavlink10.messages.sys_status.prototype.pack = function(mav) {
    return mavlink10.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.voltageBattery, this.currentBattery, this.sensorsPresent, this.sensorsEnabled, this.sensorsHealth]));
}

/* 
Inertial Measurement Unit

                xAcc                      : X acceleration. (float)
                yAcc                      : Y acceleration. (float)
                zAcc                      : Z acceleration. (float)
                xGyro                     : Angular speed around X axis. (float)
                yGyro                     : Angular speed around Y axis. (float)
                zGyro                     : Angular speed around Z axis. (float)
                xMag                      : X Magnetic field. (float)
                yMag                      : Y Magnetic field. (float)
                zMag                      : Z Magnetic field. (float)

*/
mavlink10.messages.imu = function(xAcc, yAcc, zAcc, xGyro, yGyro, zGyro, xMag, yMag, zMag) {

    this.format = '<fffffffff';
    this.id = mavlink10.MAVLINK_MSG_ID_IMU;
    this.order_map = [0, 1, 2, 3, 4, 5, 6, 7, 8];
    this.crc_extra = 53;
    this.name = 'IMU';

    this.fieldnames = ['xAcc', 'yAcc', 'zAcc', 'xGyro', 'yGyro', 'zGyro', 'xMag', 'yMag', 'zMag'];


    this.set(arguments);

}
        mavlink10.messages.imu.prototype = new mavlink10.message;
mavlink10.messages.imu.prototype.pack = function(mav) {
    return mavlink10.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.xAcc, this.yAcc, this.zAcc, this.xGyro, this.yGyro, this.zGyro, this.xMag, this.yMag, this.zMag]));
}

/* 
attitude message

                roll                      : Roll angle (-pi..+pi). (int16_t)
                pitch                     : Pitch angle (-pi..+pi). (int16_t)
                yaw                       : Yaw angle (-pi..+pi). (int16_t)

*/
mavlink10.messages.attitude = function(roll, pitch, yaw) {

    this.format = '<hhh';
    this.id = mavlink10.MAVLINK_MSG_ID_ATTITUDE;
    this.order_map = [0, 1, 2];
    this.crc_extra = 209;
    this.name = 'ATTITUDE';

    this.fieldnames = ['roll', 'pitch', 'yaw'];


    this.set(arguments);

}
        mavlink10.messages.attitude.prototype = new mavlink10.message;
mavlink10.messages.attitude.prototype.pack = function(mav) {
    return mavlink10.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.roll, this.pitch, this.yaw]));
}

/* 
the position and speed of FC

                xPosition                 : X Position (float)
                yPosition                 : Y Position (float)
                zPosition                 : Z Position (float)
                xSpeed                    : X Speed (float)
                ySpeed                    : Y Speed (float)
                zSpeed                    : Z Speed (float)

*/
mavlink10.messages.local_position = function(xPosition, yPosition, zPosition, xSpeed, ySpeed, zSpeed) {

    this.format = '<ffffff';
    this.id = mavlink10.MAVLINK_MSG_ID_LOCAL_POSITION;
    this.order_map = [0, 1, 2, 3, 4, 5];
    this.crc_extra = 245;
    this.name = 'LOCAL_POSITION';

    this.fieldnames = ['xPosition', 'yPosition', 'zPosition', 'xSpeed', 'ySpeed', 'zSpeed'];


    this.set(arguments);

}
        mavlink10.messages.local_position.prototype = new mavlink10.message;
mavlink10.messages.local_position.prototype.pack = function(mav) {
    return mavlink10.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.xPosition, this.yPosition, this.zPosition, this.xSpeed, this.ySpeed, this.zSpeed]));
}

/* 
value of rc channels

                chan1_raw                 : RC channel 1 value (int16_t)
                chan2_raw                 : RC channel 2 value (int16_t)
                chan3_raw                 : RC channel 3 value (int16_t)
                chan4_raw                 : RC channel 4 value (int16_t)
                chan5_raw                 : RC channel 5 value (int16_t)
                chan6_raw                 : RC channel 6 value (int16_t)
                chan7_raw                 : RC channel 7 value (int16_t)
                chan8_raw                 : RC channel 8 value (int16_t)
                chan9_raw                 : RC channel 9 value (int16_t)
                chan10_raw                : RC channel 10 value (int16_t)
                chan11_raw                : RC channel 11 value (int16_t)
                chan12_raw                : RC channel 12 value (int16_t)
                count                     : Total number of RC channels being received. (uint8_t)
                rssi                      : Receive signal strength indicator. Values: [0-100], 255: invalid/unknown (uint8_t)

*/
mavlink10.messages.rc_channels = function(chan1_raw, chan2_raw, chan3_raw, chan4_raw, chan5_raw, chan6_raw, chan7_raw, chan8_raw, chan9_raw, chan10_raw, chan11_raw, chan12_raw, count, rssi) {

    this.format = '<hhhhhhhhhhhhBB';
    this.id = mavlink10.MAVLINK_MSG_ID_RC_CHANNELS;
    this.order_map = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
    this.crc_extra = 45;
    this.name = 'RC_CHANNELS';

    this.fieldnames = ['chan1_raw', 'chan2_raw', 'chan3_raw', 'chan4_raw', 'chan5_raw', 'chan6_raw', 'chan7_raw', 'chan8_raw', 'chan9_raw', 'chan10_raw', 'chan11_raw', 'chan12_raw', 'count', 'rssi'];


    this.set(arguments);

}
        mavlink10.messages.rc_channels.prototype = new mavlink10.message;
mavlink10.messages.rc_channels.prototype.pack = function(mav) {
    return mavlink10.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.chan1_raw, this.chan2_raw, this.chan3_raw, this.chan4_raw, this.chan5_raw, this.chan6_raw, this.chan7_raw, this.chan8_raw, this.chan9_raw, this.chan10_raw, this.chan11_raw, this.chan12_raw, this.count, this.rssi]));
}

/* 
command

                target_component          : Component which should execute the command, 0 for all components (uint8_t)
                command                   : Command ID (of command to send). (uint16_t)
                param1                    : Parameter 1 (for the specific command). (float)
                param2                    : Parameter 2 (for the specific command). (float)

*/
mavlink10.messages.command = function(target_component, command, param1, param2) {

    this.format = '<ffHB';
    this.id = mavlink10.MAVLINK_MSG_ID_COMMAND;
    this.order_map = [3, 2, 0, 1];
    this.crc_extra = 58;
    this.name = 'COMMAND';

    this.fieldnames = ['target_component', 'command', 'param1', 'param2'];


    this.set(arguments);

}
        mavlink10.messages.command.prototype = new mavlink10.message;
mavlink10.messages.command.prototype.pack = function(mav) {
    return mavlink10.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.param1, this.param2, this.command, this.target_component]));
}

/* 
command ack

                command                   : Command ID (of acknowledged command) (uint16_t)
                result                    : Result of command. (uint8_t)

*/
mavlink10.messages.command_ack = function(command, result) {

    this.format = '<HB';
    this.id = mavlink10.MAVLINK_MSG_ID_COMMAND_ACK;
    this.order_map = [0, 1];
    this.crc_extra = 143;
    this.name = 'COMMAND_ACK';

    this.fieldnames = ['command', 'result'];


    this.set(arguments);

}
        mavlink10.messages.command_ack.prototype = new mavlink10.message;
mavlink10.messages.command_ack.prototype.pack = function(mav) {
    return mavlink10.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.command, this.result]));
}

/* 
Status text message

                severity                  : Severity of status. Relies on the definitions within RFC-5424. (uint8_t)
                text                      : Status text message, without null termination character (char)

*/
mavlink10.messages.status_text = function(severity, text) {

    this.format = '<B50s';
    this.id = mavlink10.MAVLINK_MSG_ID_STATUS_TEXT;
    this.order_map = [0, 1];
    this.crc_extra = 215;
    this.name = 'STATUS_TEXT';

    this.fieldnames = ['severity', 'text'];


    this.set(arguments);

}
        mavlink10.messages.status_text.prototype = new mavlink10.message;
mavlink10.messages.status_text.prototype.pack = function(mav) {
    return mavlink10.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.severity, this.text]));
}

/* 
motors test

                motorTestMode             : 1:enable motor test mode (uint8_t)
                ouputMotor1               : the value of motor1 testing (int16_t)
                ouputMotor2               : the value of motor2 testing (int16_t)
                ouputMotor3               : the value of motor3 testing (int16_t)
                ouputMotor4               : the value of motor4 testing (int16_t)

*/
mavlink10.messages.motors_test = function(motorTestMode, ouputMotor1, ouputMotor2, ouputMotor3, ouputMotor4) {

    this.format = '<hhhhB';
    this.id = mavlink10.MAVLINK_MSG_ID_MOTORS_TEST;
    this.order_map = [4, 0, 1, 2, 3];
    this.crc_extra = 18;
    this.name = 'MOTORS_TEST';

    this.fieldnames = ['motorTestMode', 'ouputMotor1', 'ouputMotor2', 'ouputMotor3', 'ouputMotor4'];


    this.set(arguments);

}
        mavlink10.messages.motors_test.prototype = new mavlink10.message;
mavlink10.messages.motors_test.prototype.pack = function(mav) {
    return mavlink10.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.ouputMotor1, this.ouputMotor2, this.ouputMotor3, this.ouputMotor4, this.motorTestMode]));
}

/* 
the altitude of barometer and tof

                tof                       : the altitude of tof(cm) (int16_t)
                barometer                 : the altitude of barometer(cm) (int16_t)

*/
mavlink10.messages.altitude = function(tof, barometer) {

    this.format = '<hh';
    this.id = mavlink10.MAVLINK_MSG_ID_ALTITUDE;
    this.order_map = [0, 1];
    this.crc_extra = 79;
    this.name = 'ALTITUDE';

    this.fieldnames = ['tof', 'barometer'];


    this.set(arguments);

}
        mavlink10.messages.altitude.prototype = new mavlink10.message;
mavlink10.messages.altitude.prototype.pack = function(mav) {
    return mavlink10.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.tof, this.barometer]));
}

/* 
Rate setting

                rcRateRoll                : the RC Rate of ROLL (float)
                rateRoll                  : the rate of ROLL (float)
                rcExpoRoll                : the RC Expo of ROLL (float)
                rcRatePitch               : the RC Rate of PITCH (float)
                ratePitch                 : the rate of PTICH (float)
                rcExpoPitch               : the RC Expo of PITCH (float)
                rcRateYaw                 : the RC Rate of YAW (float)
                rateYaw                   : the rate of YAW (float)
                rcExpoYaw                 : the RC Expo of YAW (float)
                throttleMid               : throttle midpoint (float)
                throttleExpo              : throttle Expo (float)

*/
mavlink10.messages.rate = function(rcRateRoll, rateRoll, rcExpoRoll, rcRatePitch, ratePitch, rcExpoPitch, rcRateYaw, rateYaw, rcExpoYaw, throttleMid, throttleExpo) {

    this.format = '<fffffffffff';
    this.id = mavlink10.MAVLINK_MSG_ID_RATE;
    this.order_map = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    this.crc_extra = 119;
    this.name = 'RATE';

    this.fieldnames = ['rcRateRoll', 'rateRoll', 'rcExpoRoll', 'rcRatePitch', 'ratePitch', 'rcExpoPitch', 'rcRateYaw', 'rateYaw', 'rcExpoYaw', 'throttleMid', 'throttleExpo'];


    this.set(arguments);

}
        mavlink10.messages.rate.prototype = new mavlink10.message;
mavlink10.messages.rate.prototype.pack = function(mav) {
    return mavlink10.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.rcRateRoll, this.rateRoll, this.rcExpoRoll, this.rcRatePitch, this.ratePitch, this.rcExpoPitch, this.rcRateYaw, this.rateYaw, this.rcExpoYaw, this.throttleMid, this.throttleExpo]));
}

/* 
PID tuning

                PID_ROLL_P                : the Proportion of PID for ROLL (float)
                PID_ROLL_I                : the Integral of PID for ROLL (float)
                PID_ROLL_D                : the Derivative of PID for ROLL (float)
                PID_ROLL_I_MAX            : the upper limit of Integral for ROLL (uint8_t)
                PID_ROLL_D_CUTFREQ        : the cut-off frequency of Derivative for ROLL (uint8_t)
                PID_PITCH_P               : the Proportion of PID for PITCH (float)
                PID_PITCH_I               : the Integral of PID for PITCH (float)
                PID_PITCH_D               : the Derivative of PID for PITCH (float)
                PID_PITCH_I_MAX           : the upper limit of Integral for PITCH (uint8_t)
                PID_PITCH_D_CUTFREQ        : the cut-off frequency of Derivative for PITCH (uint8_t)
                PID_YAW_P                 : the Proportion of PID for YAW (float)
                PID_YAW_I                 : the Integral of PID for YAW (float)
                PID_YAW_D                 : the Derivative of PID for YAW (float)
                PID_YAW_I_MAX             : the upper limit of Integral for YAW (uint8_t)
                PID_YAW_D_CUTFREQ         : the cut-off frequency of Derivative for YAW (uint8_t)

*/
mavlink10.messages.pid = function(PID_ROLL_P, PID_ROLL_I, PID_ROLL_D, PID_ROLL_I_MAX, PID_ROLL_D_CUTFREQ, PID_PITCH_P, PID_PITCH_I, PID_PITCH_D, PID_PITCH_I_MAX, PID_PITCH_D_CUTFREQ, PID_YAW_P, PID_YAW_I, PID_YAW_D, PID_YAW_I_MAX, PID_YAW_D_CUTFREQ) {

    this.format = '<fffffffffBBBBBB';
    this.id = mavlink10.MAVLINK_MSG_ID_PID;
    this.order_map = [0, 1, 2, 9, 10, 3, 4, 5, 11, 12, 6, 7, 8, 13, 14];
    this.crc_extra = 158;
    this.name = 'PID';

    this.fieldnames = ['PID_ROLL_P', 'PID_ROLL_I', 'PID_ROLL_D', 'PID_ROLL_I_MAX', 'PID_ROLL_D_CUTFREQ', 'PID_PITCH_P', 'PID_PITCH_I', 'PID_PITCH_D', 'PID_PITCH_I_MAX', 'PID_PITCH_D_CUTFREQ', 'PID_YAW_P', 'PID_YAW_I', 'PID_YAW_D', 'PID_YAW_I_MAX', 'PID_YAW_D_CUTFREQ'];


    this.set(arguments);

}
        mavlink10.messages.pid.prototype = new mavlink10.message;
mavlink10.messages.pid.prototype.pack = function(mav) {
    return mavlink10.message.prototype.pack.call(this, mav, this.crc_extra, jspack.Pack(this.format, [ this.PID_ROLL_P, this.PID_ROLL_I, this.PID_ROLL_D, this.PID_PITCH_P, this.PID_PITCH_I, this.PID_PITCH_D, this.PID_YAW_P, this.PID_YAW_I, this.PID_YAW_D, this.PID_ROLL_I_MAX, this.PID_ROLL_D_CUTFREQ, this.PID_PITCH_I_MAX, this.PID_PITCH_D_CUTFREQ, this.PID_YAW_I_MAX, this.PID_YAW_D_CUTFREQ]));
}


mavlink10.map = {
        1: { format: '<BB', type: mavlink10.messages.heartbeat, order_map: [0, 1], crc_extra: 196 },
        2: { format: '<HBBBBBB', type: mavlink10.messages.firmware_info, order_map: [1, 2, 3, 4, 0, 5, 6], crc_extra: 170 },
        3: { format: '<ffBBB', type: mavlink10.messages.sys_status, order_map: [2, 3, 4, 0, 1], crc_extra: 83 },
        4: { format: '<fffffffff', type: mavlink10.messages.imu, order_map: [0, 1, 2, 3, 4, 5, 6, 7, 8], crc_extra: 53 },
        5: { format: '<hhh', type: mavlink10.messages.attitude, order_map: [0, 1, 2], crc_extra: 209 },
        6: { format: '<ffffff', type: mavlink10.messages.local_position, order_map: [0, 1, 2, 3, 4, 5], crc_extra: 245 },
        7: { format: '<hhhhhhhhhhhhBB', type: mavlink10.messages.rc_channels, order_map: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], crc_extra: 45 },
        8: { format: '<ffHB', type: mavlink10.messages.command, order_map: [3, 2, 0, 1], crc_extra: 58 },
        9: { format: '<HB', type: mavlink10.messages.command_ack, order_map: [0, 1], crc_extra: 143 },
        10: { format: '<B50s', type: mavlink10.messages.status_text, order_map: [0, 1], crc_extra: 215 },
        11: { format: '<hhhhB', type: mavlink10.messages.motors_test, order_map: [4, 0, 1, 2, 3], crc_extra: 18 },
        12: { format: '<hh', type: mavlink10.messages.altitude, order_map: [0, 1], crc_extra: 79 },
        13: { format: '<fffffffffff', type: mavlink10.messages.rate, order_map: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], crc_extra: 119 },
        14: { format: '<fffffffffBBBBBB', type: mavlink10.messages.pid, order_map: [0, 1, 2, 9, 10, 3, 4, 5, 11, 12, 6, 7, 8, 13, 14], crc_extra: 158 },
}


// Special mavlink message to capture malformed data packets for debugging
mavlink10.messages.bad_data = function(data, reason) {
    this.id = mavlink10.MAVLINK_MSG_ID_BAD_DATA;
    this.data = data;
    this.reason = reason;
    this.msgbuf = data;
}

/* MAVLink protocol handling class */
MAVLink10Processor = function(logger, srcSystem, srcComponent) {

    this.logger = logger;

    this.seq = 0;
    this.buf = new Buffer.from([]);
    this.bufInError = new Buffer.from([]);
   
    this.srcSystem = (typeof srcSystem === 'undefined') ? 0 : srcSystem;
    this.srcComponent =  (typeof srcComponent === 'undefined') ? 0 : srcComponent;

    this.have_prefix_error = false;

    // The first packet we expect is a valid header, 6 bytes.
    this.protocol_marker = 254;   
    this.expected_length = mavlink10.HEADER_LEN;
    this.little_endian = true;

    this.crc_extra = true;
    this.sort_fields = true;
    this.total_packets_sent = 0;
    this.total_bytes_sent = 0;
    this.total_packets_received = 0;
    this.total_bytes_received = 0;
    this.total_receive_errors = 0;
    this.startup_time = Date.now();
    
}

// Implements EventEmitter
util.inherits(MAVLink10Processor, events.EventEmitter);

// If the logger exists, this function will add a message to it.
// Assumes the logger is a winston object.
MAVLink10Processor.prototype.log = function(message) {
    if(this.logger) {
        this.logger.info(message);
    }
}

MAVLink10Processor.prototype.log = function(level, message) {
    if(this.logger) {
        this.logger.log(level, message);
    }
}

MAVLink10Processor.prototype.send = function(mavmsg) {
    buf = mavmsg.pack(this);
    this.file.write(buf);
    this.seq = (this.seq + 1) % 256;
    this.total_packets_sent +=1;
    this.total_bytes_sent += buf.length;
}

// return number of bytes needed for next parsing stage
MAVLink10Processor.prototype.bytes_needed = function() {
    ret = this.expected_length - this.buf.length;
    return ( ret <= 0 ) ? 1 : ret;
}

// add data to the local buffer
MAVLink10Processor.prototype.pushBuffer = function(data) {
    if(data) {
        this.buf = Buffer.concat([this.buf, data]);
        this.total_bytes_received += data.length;
    }
}

// Decode prefix.  Elides the prefix.
MAVLink10Processor.prototype.parsePrefix = function() {

    // Test for a message prefix.
    if( this.buf.length >= 1 && this.buf[0] != this.protocol_marker ) {

        // Strip the offending initial byte and throw an error.
        var badPrefix = this.buf[0];
        this.bufInError = this.buf.slice(0,1);
        this.buf = this.buf.slice(1);
        this.expected_length = mavlink10.HEADER_LEN;

        // TODO: enable subsequent prefix error suppression if robust_parsing is implemented
        //if(!this.have_prefix_error) {
        //    this.have_prefix_error = true;
            throw new Error("Bad prefix ("+badPrefix+")");
        //}

    }
    //else if( this.buf.length >= 1 && this.buf[0] == this.protocol_marker ) {
    //    this.have_prefix_error = false;
    //}

}

// Determine the length.  Leaves buffer untouched.
MAVLink10Processor.prototype.parseLength = function() {
    
    if( this.buf.length >= 2 ) {
        var unpacked = jspack.Unpack('BB', this.buf.slice(0, 2));
        this.expected_length = unpacked[1] + mavlink10.HEADER_LEN + 2 // length of message + header + CRC
    }

}

// input some data bytes, possibly returning a new message
MAVLink10Processor.prototype.parseChar = function(c) {

    var m = null;

    try {

        this.pushBuffer(c);
        this.parsePrefix();
        this.parseLength();
        m = this.parsePayload();

    } catch(e) {

        this.log('error', e.message);
        this.total_receive_errors += 1;
        m = new mavlink10.messages.bad_data(this.bufInError, e.message);
        this.bufInError = new Buffer.from([]);
        
    }

    if(null != m) {
        this.emit(m.name, m);
        this.emit('message', m);
    }

    return m;

}

MAVLink10Processor.prototype.parsePayload = function() {

    var m = null;

    // If we have enough bytes to try and read it, read it.
    if( this.expected_length >= 8 && this.buf.length >= this.expected_length ) {

        // Slice off the expected packet length, reset expectation to be to find a header.
        var mbuf = this.buf.slice(0, this.expected_length);
        // TODO: slicing off the buffer should depend on the error produced by the decode() function
        // - if a message we find a well formed message, cut-off the expected_length
        // - if the message is not well formed (correct prefix by accident), cut-off 1 char only
        this.buf = this.buf.slice(this.expected_length);
        this.expected_length = 6;

        // w.info("Attempting to parse packet, message candidate buffer is ["+mbuf.toByteArray()+"]");

        try {
            m = this.decode(mbuf);
            this.total_packets_received += 1;
        }
        catch(e) {
            // Set buffer in question and re-throw to generic error handling
            this.bufInError = mbuf;
            throw e;
        }
    }

    return m;

}

// input some data bytes, possibly returning an array of new messages
MAVLink10Processor.prototype.parseBuffer = function(s) {
    
    // Get a message, if one is available in the stream.
    var m = this.parseChar(s);

    // No messages available, bail.
    if ( null === m ) {
        return null;
    }
    
    // While more valid messages can be read from the existing buffer, add
    // them to the array of new messages and return them.
    var ret = [m];
    while(true) {
        m = this.parseChar();
        if ( null === m ) {
            // No more messages left.
            return ret;
        }
        ret.push(m);
    }

}

/* decode a buffer as a MAVLink message */
MAVLink10Processor.prototype.decode = function(msgbuf) {

    var magic, incompat_flags, compat_flags, mlen, seq, srcSystem, srcComponent, unpacked, msgId;

    // decode the header
    try {
        unpacked = jspack.Unpack('cBBBBB', msgbuf.slice(0, 6));
        magic = unpacked[0];
        mlen = unpacked[1];
        seq = unpacked[2];
        srcSystem = unpacked[3];
        srcComponent = unpacked[4];
        msgId = unpacked[5];
        }
    catch(e) {
        throw new Error('Unable to unpack MAVLink header: ' + e.message);
    }

    if (magic.charCodeAt(0) != this.protocol_marker) {
        throw new Error("Invalid MAVLink prefix ("+magic.charCodeAt(0)+")");
    }

    if( mlen != msgbuf.length - (mavlink10.HEADER_LEN + 2)) {
        throw new Error("Invalid MAVLink message length.  Got " + (msgbuf.length - (mavlink10.HEADER_LEN + 2)) + " expected " + mlen + ", msgId=" + msgId);
    }

    if( false === _.has(mavlink10.map, msgId) ) {
        throw new Error("Unknown MAVLink message ID (" + msgId + ")");
    }

    // decode the payload
    // refs: (fmt, type, order_map, crc_extra) = mavlink10.map[msgId]
    var decoder = mavlink10.map[msgId];

    // decode the checksum
    try {
        var receivedChecksum = jspack.Unpack('<H', msgbuf.slice(msgbuf.length - 2));
    } catch (e) {
        throw new Error("Unable to unpack MAVLink CRC: " + e.message);
    }

    var messageChecksum = mavlink10.x25Crc(msgbuf.slice(1, msgbuf.length - 2));

    // Assuming using crc_extra = True.  See the message.prototype.pack() function.
    messageChecksum = mavlink10.x25Crc([decoder.crc_extra], messageChecksum);
    
    if ( receivedChecksum != messageChecksum ) {
        throw new Error('invalid MAVLink CRC in msgID ' +msgId+ ', got 0x' + receivedChecksum + ' checksum, calculated payload checkum as 0x'+messageChecksum );
    }

    var paylen = jspack.CalcLength(decoder.format);
    var payload = msgbuf.slice(mavlink10.HEADER_LEN, msgbuf.length - 2);

        // Decode the payload and reorder the fields to match the order map.
    try {
        var t = jspack.Unpack(decoder.format, payload);
    }
    catch (e) {
        throw new Error('Unable to unpack MAVLink payload type='+decoder.type+' format='+decoder.format+' payloadLength='+ payload +': '+ e.message);
    }

    // Need to check if the message contains arrays
    var args = {};
    const elementsInMsg = decoder.order_map.length;
    const actualElementsInMsg = JSON.parse(JSON.stringify(t)).length;

    if (elementsInMsg == actualElementsInMsg) {
        // Reorder the fields to match the order map
        _.each(t, function(e, i, l) {
            args[i] = t[decoder.order_map[i]]
        });
    } else {
        // This message contains arrays
        var typeIndex = 1;
        var orderIndex = 0;
        var memberIndex = 0;
        var tempArgs = {};

        // Walk through the fields 
        for(var i = 0, size = decoder.format.length-1; i <= size; ++i) {
            var order = decoder.order_map[orderIndex];
            var currentType =  decoder.format[typeIndex];

            if (isNaN(parseInt(currentType))) {
                // This field is not an array cehck the type and add it to the args
                tempArgs[orderIndex] = t[memberIndex];
                memberIndex++;
            } else {
                // This field is part of an array, need to find the length of the array
                var arraySize = ''
                var newArray = []
                while (!isNaN(decoder.format[typeIndex])) {
                    arraySize = arraySize + decoder.format[typeIndex];
                    typeIndex++;
                }

                // Now that we know how long the array is, create an array with the values
                for(var j = 0, size = parseInt(arraySize); j < size; ++j){
                    newArray.push(t[j+orderIndex]);
                    memberIndex++;
                }

                // Add the array to the args object
                arraySize = arraySize + decoder.format[typeIndex];
                currentType = arraySize;
                tempArgs[orderIndex] = newArray;
            }
            orderIndex++;
            typeIndex++;
        }

        // Finally reorder the fields to match the order map
        _.each(t, function(e, i, l) {
            args[i] = tempArgs[decoder.order_map[i]]
        });
    }

    // construct the message object
    try {
        var m = new decoder.type(args);
        m.set.call(m, args);
    }
    catch (e) {
        throw new Error('Unable to instantiate MAVLink message of type '+decoder.type+' : ' + e.message);
    }
    m.msgbuf = msgbuf;
    m.payload = payload
    m.crc = receivedChecksum;
    m.header = new mavlink10.header(msgId, mlen, seq, srcSystem, srcComponent, incompat_flags, compat_flags);
    this.log(m);
    return m;
}


// Expose this code as a module
module.exports = {mavlink10, MAVLink10Processor};

